

/**
 * Note, this code is strongly based off of the code from
 * Yaoliang's slides in class for the merge-sort algorithm.
 */

// O(n)
function modified_merge_step(A, p, q, r)
  // copy the left piece
  for i = 1 to q − p + 1 do
    L[i] = A[p + i − 1]
  // copy the right piece
  for j = 1 to r − q do
    R[j] = A[q + j]

  i = 1
  j = 1

  for k = p to r do
    if j > r − q then 
      A[k] = L[i], i++
    else if i <= q − p + 1 && L[i] ≤ R[j] then
      A[k] = L[i]
      i = i + 1
    else
      A[k] = R[j]
      j = j + 1
      count = count + 1

/**
 * Returns the number of conflicts in the array.
 */
function count_conflicts(array, p, q)
  // base case, no conflicts, thus return 0.
  if not p < r then
    return 0
  else
    q = floor( (p + r) / 2 )

    // recurse over each half and merge. modified_merge_step returns the count of  
    return (
      count_conflicts ( A, p, q ) +    // T(n/2)
      count_conflicts (A, q, r) +      // T(n/2)
      modified_merge_step (A, p, q, r) // O(n)
    )
